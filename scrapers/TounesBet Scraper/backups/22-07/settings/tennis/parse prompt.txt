i want to parse the odds from the match id response response that i sent you, this response is is from tennis match, i have a code that parse a football match id response take a look at it to have an idea on the process, note that the football match can contain odds that are not present in the tennis match and vice versa (they are not the same, like for example the draw odd is not present in tennis matches unlike football matches). make this code easy to customize its parsing mechanisms : i want to easily modify the odds markers and odds exporting names and add new ones , this will help me add new odds names and their markers more easily , i want the customization to happen in a file named parsing.json, in the parsing file there will be 3 odds types : regular type (like 1 odd, 2 odd) and regular odds like home wins two sets etc..... the other type is total and the the third type is handicap. this will make it easier to add new regular odds, or new total lines (first half total, sets total,...), or new handicap lines (first half handicap, etc....)
write the parsing function, the function that loads the parsing file and the parsing file.
this is the football parsing function : "def parse_live_match_odds(html: str) -> dict:
    """
    Final robust parser. Handles both English and French market names.
    """
    soup = BeautifulSoup(html, 'html.parser')
    odds = {}

    def norm_val(v):
        try:
            return float(v.replace(',', '.').strip())
        except (ValueError, TypeError, AttributeError):
            return None

    def norm_text(text):
        # Normalize to remove accents and standardize text for reliable matching.
        if not text: return ""
        s = unicodedata.normalize('NFKD', text.lower()).encode('ascii', 'ignore').decode('utf-8')
        return s.replace("'", "").replace("-", " ").strip()

    # Iterate through each market row on the page
    for row in soup.select('.divOddRow.live_detail_market'):
        mname_elem = row.select_one('.oddName span')
        if not mname_elem:
            continue

        market_title = mname_elem.get_text(strip=True)
        norm_title = norm_text(market_title)

        if DEBUG_PARSER:
            safe_print(f"DEBUG: Found Market Title: '{market_title}' / Normalized: '{norm_title}'")

        # --- Handle all market types based on normalized titles ---

        # 1X2 / RÃ©sultat du match
        if norm_title == 'resultat du match' or norm_title == '1x2':
            mapping = {'1': '1_odd', 'x': 'draw_odd', '2': '2_odd'}
            for mo in row.select('.match-odd[data-isactive="True"]'):
                lbl = mo.select_one('.outcome-label-multirow').text.strip().lower()
                val = mo.select_one('.quoteValue')['data-oddvaluedecimal']
                if lbl in mapping: odds[mapping[lbl]] = norm_val(val)
            continue

        # Double Chance
        if norm_title == 'double chance':
            mapping = {'1x': '1X_odd', '12': '12_odd', 'x2': 'X2_odd'}
            for mo in row.select('.match-odd[data-isactive="True"]'):
                lbl = mo.select_one('.outcome-label-multirow').text.strip().lower()
                val = mo.select_one('.quoteValue')['data-oddvaluedecimal']
                if lbl in mapping: odds[mapping[lbl]] = norm_val(val)
            continue

        # Both Teams to Score / Les deux equipes marquent
        if norm_title == 'les deux equipes marquent' or norm_title == 'both teams to score':
            for mo in row.select('.match-odd[data-isactive="True"]'):
                lbl = mo.select_one('.outcome-label-multirow').text.strip().lower()
                val = mo.select_one('.quoteValue')['data-oddvaluedecimal']
                if lbl in ('oui', 'yes'):
                    odds['both_score_odd'] = norm_val(val)
                elif lbl in ('non', 'no'):
                    odds['both_noscore_odd'] = norm_val(val)
            continue

        # Team to score in both halves
        if 'to score in both halves' in norm_title or 'va marquer dans les deux mi temps' in norm_title:
            team_prefix = "home" if "home team" in norm_title or "domicile" in norm_title else "away"
            for mo in row.select('.match-odd[data-isactive="True"]'):
                lbl = mo.select_one('.outcome-label-multirow').text.strip().lower()
                val = mo.select_one('.quoteValue')['data-oddvaluedecimal']
                if lbl in ('oui', 'yes'):
                    odds[f'{team_prefix}_score_both_halves_odd'] = norm_val(val)
                elif lbl in ('non', 'no'):
                    odds[f'{team_prefix}_noscore_both_halves_odd'] = norm_val(val)
            continue

        # Team to score in 2nd half
        if 'to score 2nd half' in norm_title or 'va marquer la 2eme mi temps' in norm_title:
            team_prefix = "home" if "home team" in norm_title or "domicile" in norm_title else "away"
            for mo in row.select('.match-odd[data-isactive="True"]'):
                lbl = mo.select_one('.outcome-label-multirow').text.strip().lower()
                val = mo.select_one('.quoteValue')['data-oddvaluedecimal']
                if lbl in ('oui', 'yes'):
                    odds[f'{team_prefix}_score_second_half_odd'] = norm_val(val)
                elif lbl in ('non', 'no'):
                    odds[f'{team_prefix}_noscore_second_half_odd'] = norm_val(val)
            continue

        # All Under/Over markets
        is_under_over_market = 'under / over' in norm_title or 'under/over' in norm_title or 'total corners' in norm_title or '1st half' in norm_title
        if is_under_over_market:
            prefix = ""
            if "1st half" in norm_title:
                prefix = "first_half_"
            elif "home team" in norm_title or "domicile" in norm_title:
                prefix = "home_"
            elif "away team" in norm_title or "exterieure" in norm_title:
                prefix = "away_"
            elif "corners" in norm_title:
                prefix = "corners_"

            for holder in row.select('.odds_type_holder[data-specialoddsvalue]'):
                line_raw = holder.get('data-specialoddsvalue', '')
                if not re.match(r'^\d+(\.\d+)?$', line_raw): continue
                line_str = str(float(line_raw))

                for div in holder.select('.has-specialBet-col'):
                    mo_tag = div.select_one('.match-odd[data-isactive="True"]')
                    if not mo_tag: continue

                    lbl_tag = mo_tag.select_one('label')
                    val_tag = mo_tag.select_one('.quoteValue')
                    if not (lbl_tag and val_tag and val_tag.has_attr('data-oddvaluedecimal')): continue

                    lbl = lbl_tag.text.strip().lower()
                    val = val_tag['data-oddvaluedecimal']
                    outcome = 'under' if lbl in ('moins', 'under') else 'over' if lbl in ('plus', 'over') else None
                    if outcome:
                        key = f"{prefix}{outcome}_{line_str}_odd"
                        odds[key] = norm_val(val)
            continue

    return odds"
ofc the tennis parser will not totally copy the football parser as they do not necessarily have the sam emarkers for odds between them (im not sure about that) but will try to find the markers of each odds
for a beginning the parser will parse these odds (i can add more later in the parsing json) : i will add the values that re existent in the example response i sent you so you can find them :
1_odd :
