from supabase import create_client
import os
from datetime import datetime

class SupabaseExporter:
    def __init__(self, supabase_url, supabase_key):
        """Initialize Supabase client with connection details."""
        self.supabase = create_client(supabase_url, supabase_key)
        
    def export_arbitrage_opportunity(self, opportunity):
        """
        Export a single arbitrage opportunity to Supabase.
        
        Args:
            opportunity (dict): The arbitrage opportunity data in the exact format
            generated by the arbitrage checker.
        """
        try:
            # Utiliser directement le format original
            # Ajouter uniquement un timestamp pour Supabase
            data = opportunity.copy()
            data['created_at'] = datetime.now().isoformat()
            
            # L'ID unique est déjà inclus dans le group_id
            
            # Préparer les données pour Supabase
            supabase_data = {
                'group_id': data['group_id'],
                'data': data,  # Stocker tout le JSON original dans le champ data
                'created_at': datetime.now().isoformat()
            }
            
            # Insérer ou mettre à jour les données
            result = (self.supabase
                     .table('opportunities')
                     .upsert(supabase_data, on_conflict='group_id')
                     .execute())
            return True, result.data
            
        except Exception as e:
            return False, str(e)
            
    def export_multiple_opportunities(self, opportunities):
        """
        Export multiple arbitrage opportunities to Supabase.
        
        Args:
            opportunities (list): List of arbitrage opportunity dictionaries
        
        Returns:
            tuple: (success_count, error_count, errors)
        """
        success_count = 0
        error_count = 0
        errors = []
        
        for opp in opportunities:
            success, result = self.export_arbitrage_opportunity(opp)
            if success:
                success_count += 1
            else:
                error_count += 1
                errors.append(f"Error with match {opp.get('match_id', 'unknown')}: {result}")
                
        return success_count, error_count, errors

    def export_opportunities(self, opportunities):
        """
        Backwards-compatible wrapper expected by main.py.
        Accepts a list of opportunity dicts and returns a dict with counts.
        """
        success_count, error_count, errors = self.export_multiple_opportunities(opportunities)
        return {
            'success': success_count,
            'failed': error_count,
            'errors': errors
        }

    # Storage helpers
    def upload_file_to_storage(self, bucket: str, remote_path: str, file_bytes: bytes):
        """
        Upload raw bytes to a Supabase Storage bucket. Returns (True, resp) on success,
        or (False, error) on failure. Will replace existing files.
        """
        try:
            storage = self.supabase.storage
            # Essayer d'abord de supprimer le fichier existant
            try:
                storage.from_(bucket).remove([remote_path])
            except:
                pass  # Ignorer les erreurs si le fichier n'existe pas
                
            # Uploader le nouveau fichier
            resp = storage.from_(bucket).upload(remote_path, file_bytes)
            
            # supabase-py returns dict-like with 'error' key when something goes wrong
            if isinstance(resp, dict) and resp.get('error'):
                return False, resp
            return True, resp
        except Exception as e:
            return False, str(e)

    def create_bucket_if_missing(self, bucket: str):
        try:
            return self.supabase.storage.create_bucket(bucket)
        except Exception as e:
            return {'error': str(e)}

    def list_files(self, bucket: str, prefix: str = ''):
        """
        List objects under a prefix in the given bucket. Returns a list of object keys (str).
        """
        try:
            items = self.supabase.storage.from_(bucket).list(prefix)
            # items is expected to be a list of dicts with at least 'name' or 'id'
            paths = []
            for it in items:
                if isinstance(it, dict):
                    # common keys: 'name' or 'id' or 'path'
                    path = it.get('name') or it.get('id') or it.get('path')
                    if path:
                        paths.append(path)
                elif isinstance(it, str):
                    paths.append(it)
            return paths
        except Exception as e:
            return {'error': str(e)}

    def remove_file(self, bucket: str, path: str):
        """
        Remove a single object from the bucket. Returns (True, resp) or (False, error).
        """
        try:
            resp = self.supabase.storage.from_(bucket).remove([path])
            if isinstance(resp, dict) and resp.get('error'):
                return False, resp
            return True, resp
        except Exception as e:
            return False, str(e)

    def prune_remote_files(self, bucket: str, expected_paths: set, prefix: str = ''):
        """
        Remove remote files under the given prefix that are not present in expected_paths.

        Args:
            bucket (str): storage bucket name
            expected_paths (set): full remote paths that should be kept
            prefix (str): optional prefix to limit listing/pruning scope

        Returns:
            (True, {'deleted': [...], 'failed': [...]}) on success or (False, error)
        """
        try:
            # Liste des fichiers distants sous le préfixe
            remote_list = self.list_files(bucket, prefix)
            if isinstance(remote_list, dict) and remote_list.get('error'):
                return False, remote_list

            deleted = []
            failed = []

            # Helper de normalisation
            def norm(p: str) -> str:
                if not isinstance(p, str):
                    return ''
                return p.replace('\\', '/').lstrip('/')

            normalized_expected = set(norm(p) for p in (expected_paths or []))
            norm_prefix = norm(prefix).rstrip('/')

            for remotepath in remote_list:
                rnorm = norm(remotepath)

                # Construire variantes pour comparaison
                variants = {rnorm}
                if norm_prefix:
                    variants.add(f"{norm_prefix}/{rnorm}")
                    # si remotepath contient prefix already, ajouter sans prefix
                    if rnorm.startswith(f"{norm_prefix}/"):
                        variants.add(rnorm[len(norm_prefix) + 1:])

                # Déterminer si on doit garder le fichier distant
                keep = False
                for exp in normalized_expected:
                    if not exp:
                        continue
                    # égalité directe
                    if exp in variants:
                        keep = True
                        break
                    # comparaison par suffixe pour attraper 'rel' vs 'prefix/rel'
                    for v in variants:
                        if v and (v.endswith(exp) or exp.endswith(v)):
                            keep = True
                            break
                    if keep:
                        break

                if keep:
                    continue

                # Supprimer le fichier distant (utiliser le chemin tel que retourné par list_files)
                ok, resp = self.remove_file(bucket, remotepath)
                if ok:
                    # Vérifier qu'il a bien disparu (re-lister)
                    post_list = self.list_files(bucket, prefix)
                    still_there = False
                    if isinstance(post_list, dict) and post_list.get('error'):
                        # si on ne peut pas lister, on considère la suppression comme réussie
                        deleted.append(remotepath)
                        continue
                    else:
                        # Normaliser la nouvelle liste
                        post_norm = set(norm(p) for p in (post_list or []))
                        if norm(remotepath) in post_norm or any(norm(remotepath).endswith(p) or p.endswith(norm(remotepath)) for p in post_norm):
                            still_there = True

                    # Si toujours présent, tenter des variantes de suppression
                    if still_there:
                        tried = []
                        variants_to_try = [remotepath, rnorm, f"{norm_prefix}/{rnorm}" if norm_prefix else rnorm, f"/{rnorm}"]
                        for alt in variants_to_try:
                            if not alt or alt in tried:
                                continue
                            tried.append(alt)
                            try:
                                ok2, resp2 = self.remove_file(bucket, alt)
                                if ok2:
                                    # re-check
                                    post_list2 = self.list_files(bucket, prefix)
                                    post_norm2 = set(norm(p) for p in (post_list2 or [])) if not (isinstance(post_list2, dict) and post_list2.get('error')) else set()
                                    if norm(alt) not in post_norm2 and not any(norm(alt).endswith(p) or p.endswith(norm(alt)) for p in post_norm2):
                                        deleted.append(remotepath)
                                        still_there = False
                                        break
                            except Exception:
                                pass

                    if still_there:
                        # Signalons en échec si l'objet est toujours présent
                        failed.append({'path': remotepath, 'error': 'still_present_after_delete'})
                    else:
                        deleted.append(remotepath)
                else:
                    failed.append({'path': remotepath, 'error': resp})

            return True, {'deleted': deleted, 'failed': failed}
        except Exception as e:
            return False, str(e)